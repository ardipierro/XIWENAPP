import logger from '../utils/logger';

import {
  collection,
  addDoc,
  doc,
  getDoc,
  getDocs,
  updateDoc,
  query,
  where,
  orderBy,
  serverTimestamp,
  Timestamp
} from 'firebase/firestore';
import { db } from './config';
import { getNextClassDate } from './scheduledClasses';

// ============================================
// SESIONES DE CLASE (INSTANCIAS INDIVIDUALES)
// ============================================

/**
 * Crear una sesión de clase individual
 * @param {Object} sessionData - Datos de la sesión
 * @returns {Promise<Object>} - {success: boolean, id?: string, error?: string}
 */
export async function createClassSession(sessionData) {
  try {
    const {
      scheduledClassId,
      groupId,
      groupName,
      courseName,
      date, // Date object
      startTime,
      endTime,
      meetingLink,
      creditCost = 1,
      teacherId,
      autoGenerated = false
    } = sessionData;

    if (!scheduledClassId || !groupId || !date) {
      return { success: false, error: 'Faltan campos obligatorios' };
    }

    const sessionDoc = {
      scheduledClassId,
      groupId,
      groupName: groupName || '',
      courseName: courseName || '',
      date: Timestamp.fromDate(date),
      startTime,
      endTime,
      meetingLink: meetingLink || '',
      creditCost,
      teacherId,
      autoGenerated,
      status: 'scheduled', // scheduled, in_progress, completed, cancelled
      linkActive: false, // se activa 15min antes
      createdAt: serverTimestamp(),
      updatedAt: serverTimestamp()
    };

    const docRef = await addDoc(collection(db, 'class_sessions'), sessionDoc);

    return { success: true, id: docRef.id };
  } catch (error) {
    logger.error('Error al crear sesión:', error);
    return { success: false, error: error.message };
  }
}

/**
 * Generar sesiones para las próximas N semanas
 * @param {string} scheduledClassId - ID de la clase programada
 * @param {Object} classData - Datos de la clase (dayOfWeek, startTime, etc)
 * @param {number} weeksAhead - Semanas a generar (default: 4)
 * @returns {Promise<Object>} - {success: boolean, created: number, error?: string}
 */
export async function generateSessionsForScheduledClass(scheduledClassId, classData, weeksAhead = 4) {
  try {
    const {
      groupId,
      groupName,
      courseName,
      dayOfWeek,
      startTime,
      endTime,
      meetingLink,
      creditCost,
      teacherId
    } = classData;

    let created = 0;

    for (let week = 0; week < weeksAhead; week++) {
      const sessionDate = getNextClassDate(dayOfWeek, startTime);
      sessionDate.setDate(sessionDate.getDate() + (week * 7));

      // Verificar si ya existe una sesión para esta fecha
      const exists = await sessionExistsForDate(scheduledClassId, sessionDate);
      if (exists) continue;

      const result = await createClassSession({
        scheduledClassId,
        groupId,
        groupName,
        courseName,
        date: sessionDate,
        startTime,
        endTime,
        meetingLink,
        creditCost,
        teacherId,
        autoGenerated: true
      });

      if (result.success) created++;
    }

    return { success: true, created };
  } catch (error) {
    logger.error('Error al generar sesiones:', error);
    return { success: false, created: 0, error: error.message };
  }
}

/**
 * Verificar si existe una sesión para una fecha específica
 * @param {string} scheduledClassId - ID de la clase programada
 * @param {Date} date - Fecha a verificar
 * @returns {Promise<boolean>} - true si existe
 */
async function sessionExistsForDate(scheduledClassId, date) {
  try {
    const startOfDay = new Date(date);
    startOfDay.setHours(0, 0, 0, 0);

    const endOfDay = new Date(date);
    endOfDay.setHours(23, 59, 59, 999);

    const q = query(
      collection(db, 'class_sessions'),
      where('scheduledClassId', '==', scheduledClassId),
      where('date', '>=', Timestamp.fromDate(startOfDay)),
      where('date', '<=', Timestamp.fromDate(endOfDay))
    );

    const snapshot = await getDocs(q);
    return !snapshot.empty;
  } catch (error) {
    logger.error('Error al verificar sesión:', error);
    return false;
  }
}

/**
 * Obtener una sesión por ID
 * @param {string} sessionId - ID de la sesión
 * @returns {Promise<Object|null>} - Sesión o null
 */
export async function getClassSession(sessionId) {
  try {
    const docRef = doc(db, 'class_sessions', sessionId);
    const docSnap = await getDoc(docRef);

    if (docSnap.exists()) {
      return { id: docSnap.id, ...docSnap.data() };
    }
    return null;
  } catch (error) {
    logger.error('Error al obtener sesión:', error);
    return null;
  }
}

/**
 * Obtener sesiones de un grupo
 * @param {string} groupId - ID del grupo
 * @param {Date} startDate - Fecha inicial (opcional)
 * @param {Date} endDate - Fecha final (opcional)
 * @returns {Promise<Array>} - Lista de sesiones
 */
export async function getGroupSessions(groupId, startDate = null, endDate = null) {
  try {
    let q;

    if (startDate && endDate) {
      q = query(
        collection(db, 'class_sessions'),
        where('groupId', '==', groupId),
        where('date', '>=', Timestamp.fromDate(startDate)),
        where('date', '<=', Timestamp.fromDate(endDate)),
        orderBy('date', 'desc')
      );
    } else {
      q = query(
        collection(db, 'class_sessions'),
        where('groupId', '==', groupId),
        orderBy('date', 'desc')
      );
    }

    const snapshot = await getDocs(q);
    return snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
  } catch (error) {
    logger.error('Error al obtener sesiones del grupo:', error);
    return [];
  }
}

/**
 * Obtener sesiones de un profesor
 * @param {string} teacherId - ID del profesor
 * @param {Date} startDate - Fecha inicial (opcional)
 * @param {Date} endDate - Fecha final (opcional)
 * @returns {Promise<Array>} - Lista de sesiones
 */
export async function getTeacherSessions(teacherId, startDate = null, endDate = null) {
  try {
    let q;

    if (startDate && endDate) {
      q = query(
        collection(db, 'class_sessions'),
        where('teacherId', '==', teacherId),
        where('date', '>=', Timestamp.fromDate(startDate)),
        where('date', '<=', Timestamp.fromDate(endDate)),
        orderBy('date', 'desc')
      );
    } else {
      q = query(
        collection(db, 'class_sessions'),
        where('teacherId', '==', teacherId),
        orderBy('date', 'desc')
      );
    }

    const snapshot = await getDocs(q);
    return snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
  } catch (error) {
    logger.error('Error al obtener sesiones del profesor:', error);
    return [];
  }
}

/**
 * Obtener sesiones próximas (futuras)
 * @param {string} groupId - ID del grupo (opcional)
 * @param {number} limit - Límite de resultados
 * @returns {Promise<Array>} - Lista de sesiones
 */
export async function getUpcomingSessions(groupId = null, limit = 10) {
  try {
    const now = new Date();
    let q;

    if (groupId) {
      q = query(
        collection(db, 'class_sessions'),
        where('groupId', '==', groupId),
        where('date', '>=', Timestamp.fromDate(now)),
        where('status', '==', 'scheduled'),
        orderBy('date', 'asc')
      );
    } else {
      q = query(
        collection(db, 'class_sessions'),
        where('date', '>=', Timestamp.fromDate(now)),
        where('status', '==', 'scheduled'),
        orderBy('date', 'asc')
      );
    }

    const snapshot = await getDocs(q);
    const sessions = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));

    return sessions.slice(0, limit);
  } catch (error) {
    logger.error('Error al obtener sesiones próximas:', error);
    return [];
  }
}

/**
 * Actualizar estado de una sesión
 * @param {string} sessionId - ID de la sesión
 * @param {string} status - Nuevo estado
 * @returns {Promise<Object>} - {success: boolean, error?: string}
 */
export async function updateSessionStatus(sessionId, status) {
  try {
    const validStatuses = ['scheduled', 'in_progress', 'completed', 'cancelled'];
    if (!validStatuses.includes(status)) {
      return { success: false, error: 'Estado inválido' };
    }

    const docRef = doc(db, 'class_sessions', sessionId);
    await updateDoc(docRef, {
      status,
      updatedAt: serverTimestamp()
    });

    return { success: true };
  } catch (error) {
    logger.error('Error al actualizar estado de sesión:', error);
    return { success: false, error: error.message };
  }
}

/**
 * Activar link de meeting (se ejecuta automáticamente 15min antes)
 * @param {string} sessionId - ID de la sesión
 * @returns {Promise<Object>} - {success: boolean, error?: string}
 */
export async function activateSessionLink(sessionId) {
  try {
    const docRef = doc(db, 'class_sessions', sessionId);
    await updateDoc(docRef, {
      linkActive: true,
      updatedAt: serverTimestamp()
    });

    return { success: true };
  } catch (error) {
    logger.error('Error al activar link:', error);
    return { success: false, error: error.message };
  }
}

/**
 * Verificar si el link de una sesión está activo
 * @param {Object} session - Objeto de sesión
 * @returns {boolean} - true si el link está activo
 */
export function isSessionLinkActive(session) {
  if (!session || !session.date || !session.startTime) return false;

  // Ya marcado como activo manualmente
  if (session.linkActive) return true;

  const now = new Date();
  const sessionDate = session.date.toDate ? session.date.toDate() : new Date(session.date);

  const [hours, minutes] = session.startTime.split(':').map(Number);
  sessionDate.setHours(hours, minutes, 0, 0);

  // Activo 15 minutos antes y hasta 15 minutos después del inicio
  const activationTime = new Date(sessionDate.getTime() - 15 * 60000);
  const deactivationTime = new Date(sessionDate.getTime() + 15 * 60000);

  return now >= activationTime && now <= deactivationTime;
}

/**
 * Cancelar una sesión
 * @param {string} sessionId - ID de la sesión
 * @param {string} reason - Razón de cancelación
 * @returns {Promise<Object>} - {success: boolean, error?: string}
 */
export async function cancelSession(sessionId, reason = '') {
  try {
    const docRef = doc(db, 'class_sessions', sessionId);
    await updateDoc(docRef, {
      status: 'cancelled',
      cancellationReason: reason,
      cancelledAt: serverTimestamp(),
      updatedAt: serverTimestamp()
    });

    return { success: true };
  } catch (error) {
    logger.error('Error al cancelar sesión:', error);
    return { success: false, error: error.message };
  }
}

/**
 * Obtener estadísticas de sesiones para un horario programado
 * @param {string} scheduledClassId - ID de la clase programada
 * @returns {Promise<Object>} - Estadísticas de sesiones
 */
export async function getScheduledClassStats(scheduledClassId) {
  try {
    const q = query(
      collection(db, 'class_sessions'),
      where('scheduledClassId', '==', scheduledClassId)
    );

    const snapshot = await getDocs(q);
    const sessions = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));

    const now = new Date();

    const completed = sessions.filter(s => s.status === 'completed').length;
    const cancelled = sessions.filter(s => s.status === 'cancelled').length;
    const upcoming = sessions.filter(s => {
      const sessionDate = s.date?.toDate ? s.date.toDate() : new Date(s.date);
      return sessionDate > now && s.status === 'scheduled';
    }).length;
    const past = sessions.filter(s => {
      const sessionDate = s.date?.toDate ? s.date.toDate() : new Date(s.date);
      return sessionDate <= now && s.status === 'scheduled';
    }).length;

    // Próxima sesión
    const upcomingSessions = sessions
      .filter(s => {
        const sessionDate = s.date?.toDate ? s.date.toDate() : new Date(s.date);
        return sessionDate > now && s.status === 'scheduled';
      })
      .sort((a, b) => {
        const dateA = a.date?.toMillis ? a.date.toMillis() : 0;
        const dateB = b.date?.toMillis ? b.date.toMillis() : 0;
        return dateA - dateB;
      });

    const nextSession = upcomingSessions.length > 0 ? upcomingSessions[0] : null;

    return {
      total: sessions.length,
      completed,
      cancelled,
      upcoming,
      past,
      nextSession,
      allSessions: sessions.sort((a, b) => {
        const dateA = a.date?.toMillis ? a.date.toMillis() : 0;
        const dateB = b.date?.toMillis ? b.date.toMillis() : 0;
        return dateB - dateA; // Más reciente primero
      })
    };
  } catch (error) {
    logger.error('Error al obtener estadísticas de sesiones:', error);
    return {
      total: 0,
      completed: 0,
      cancelled: 0,
      upcoming: 0,
      past: 0,
      nextSession: null,
      allSessions: []
    };
  }
}
